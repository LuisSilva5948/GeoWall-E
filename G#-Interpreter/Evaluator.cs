using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Markup;

namespace GSharpInterpreter
{
    /// <summary>
    /// Represents an evaluator that evaluates the syntax tree generated by the parser and produces the corresponding runtime values.
    /// </summary>
    public class Evaluator
    {
        private Scope Scope;                                // The scope of the evaluator
        private Stack<Dictionary<string, object>> Scopes;   // The stack of scopes
        private readonly int CallLimit = 100;               // The maximum amount of calls allowed
        private int Calls;                                  // The amount of calls made
        public List<Error> Errors { get; private set; }     // The list of errors encountered during the evaluation

        public Evaluator()
        {
            Errors = new List<Error>();
            Scope = new Scope();
            Scopes = new Stack<Dictionary<string, object>>();
            Scopes.Push(new Dictionary<string, object>());
        }
        /*/// <summary>
        /// Creates a new scope with the values of the current scope and pushes it to the stack of scopes.
        /// </summary>
        private void PushScope()
        {
            Dictionary<string, object> newScope = new Dictionary<string, object>();
            foreach (var keyvaluepair in CurrentScope())
                newScope[keyvaluepair.Key] = keyvaluepair.Value;
            Scopes.Push(newScope);
        }
        /// <summary>
        /// Removes the topmost scope from the stack of scopes.
        /// </summary>
        private void PopScope()
        {
            Scopes.Pop();
        }
        /// <summary>
        /// Gets the current scope from the stack of scopes.
        /// </summary>
        private Dictionary<string, object> CurrentScope()
        {
            return this.Scopes.Peek();
        }*/
        public void Evaluate(List<Expression> AST)
        {
            // Evaluate the expressions
            foreach (Expression expression in AST)
            {
                try
                {
                    Evaluate(expression);
                }
                catch(Error error)
                {
                    Errors.Add(error);
                }
                catch (Exception e)
                {
                    Errors.Add(new Error(ErrorType.RUNTIME, e.Message));
                }
            }
        }
        /// <summary>
        /// Evaluates the given expression and returns the result.
        /// </summary>
        /// <param name="expression">The expression to evaluate.</param>
        /// <returns>The result of the evaluation.</returns>
        public object Evaluate(Expression expression)
        {
            // Check if the amount of calls exceeds the call limit
            if (Calls > CallLimit)
                throw new Error(ErrorType.RUNTIME, "Stack Overflow.");

            // Evaluate the expression
            switch (expression)
            {
                case LiteralExpression literal:
                    return literal.Value;
                case UnaryExpression unary:
                    return EvaluateUnary(unary.Operator, Evaluate(unary.Right));
                case BinaryExpression binary:
                    return EvaluateBinary(Evaluate(binary.Left), binary.Operator, Evaluate(binary.Right));
                case GroupingExpression grouping:
                    return Evaluate(grouping.Expression);
                case ConstantExpression constant:
                    return Scope.GetValue(constant.ID);
                    //return EvaluateConstant(constant.ID);
                case Assignment assign:
                    Scope.SetConstant(assign.ID, Evaluate(assign.Value));
                    return $"Constant '{assign.ID}' was declared succesfully.";
                    //return CurrentScope()[assign.ID] = Evaluate(assign.Value);
                case Conditional ifElse:
                    return EvaluateIfElse(ifElse);
                case LetExpression letIn:
                    return EvaluateLetIn(letIn);
                case Function function:
                    EvaluateFunction(function);
                    return "Function declared";
                case Call call:
                    return EvaluateCall(call);
                case GeometricExpression geometric:
                    throw new Exception("Geometric Expressions are not supported yet.");
                case RandomDeclaration randomDeclaration:
                    return EvaluateRandomDeclaration(randomDeclaration);
                case MultipleAssignment multipleAssignment:
                    return EvaluateMultipleAssignment(multipleAssignment);
                case PrintStatement print:
                    Interpreter.UI.Print(Evaluate(print.Expression).ToString());
                    return "Printed";

                default:
                    throw new Error(ErrorType.COMPILING, "Invalid expression.");
            }   
        }

        private void EvaluateFunction(Function function)
        {
            // Check if the parameters are valid
            foreach (ConstantExpression parameter in function.Parameters)
            {
                if (parameter.ID == "_")
                    throw new Error(ErrorType.COMPILING, "Function parameters can't be named '_'.");
                if (Scope.Exists(parameter.ID))
                    throw new Error(ErrorType.COMPILING, $"Another identifier named '{parameter.ID}' already exists and can't be altered.");
            }
            // Reserve the parameters in the scope
            foreach (ConstantExpression parameter in function.Parameters)
            {
                Scope.Reserve(parameter.ID);
            }
            // Add the function to the declared functions
            StandardLibrary.DeclaredFunctions[function.Identifier] = function;
        }

        private object EvaluateMultipleAssignment(MultipleAssignment multipleAssignment)
        {
            List<string> variables = multipleAssignment.IDs;
            Expression sequence = (Sequence)multipleAssignment.Sequence;
            throw new NotImplementedException();
        }


        /// <summary>
        /// Evaluates a binary expression by performing the corresponding operation on the left and right operands.
        /// </summary>
        /// <param name="left">The left operand.</param>
        /// <param name="Operator">The binary operator.</param>
        /// <param name="right">The right operand.</param>
        /// <returns>The result of the binary operation.</returns>
        public object EvaluateBinary(object left, Token Operator, object right)
        {
            switch (Operator.Type)
            {
                case TokenType.ADDITION:
                    try
                    {
                        CheckNumbers(Operator, left, right);
                    }
                    catch(Error)
                    {
                        if (left is string || right is string)
                            return left.ToString() + right.ToString();
                        throw new Error(ErrorType.COMPILING, $"Operands must be Numbers or Strings in '{Operator.Lexeme}' operation.");
                    }
                    return (double)left + (double)right;


                case TokenType.SUBSTRACTION:
                    CheckNumbers(Operator, left, right);
                    return (double)left - (double)right;
                case TokenType.MULTIPLICATION:
                    CheckNumbers(Operator, left, right);
                    return (double)left * (double)right;
                case TokenType.DIVISION:
                    CheckNumbers(Operator, left, right);
                    if ((double)right != 0)
                        return (double)left / (double)right;
                    throw new Error(ErrorType.COMPILING, "Division by zero is undefined.");
                case TokenType.MODULO:
                    CheckNumbers(Operator, left, right);
                    return (double)left % (double)right;
                case TokenType.POWER:
                    CheckNumbers(Operator, left, right);
                    return Math.Pow((double)left, (double)right);
                case TokenType.GREATER:
                    CheckNumbers(Operator, left, right);
                    return (double)left > (double)right;
                case TokenType.GREATER_EQUAL:
                    CheckNumbers(Operator, left, right);
                    return (double)left >= (double)right;
                case TokenType.LESS:
                    CheckNumbers(Operator, left, right);
                    return (double)left < (double)right;
                case TokenType.LESS_EQUAL:
                    CheckNumbers(Operator, left, right);
                    return (double)left <= (double)right;

                case TokenType.EQUAL:
                    return IsEqual(left, right);
                case TokenType.NOT_EQUAL:
                    return !IsEqual(left, right);

                case TokenType.AND:
                    CheckBooleans(Operator, left, right);
                    return (bool)left && (bool)right;
                case TokenType.OR:
                    CheckBooleans(Operator, left, right);
                    return (bool)left || (bool)right;

                default:
                    return null;
            }
        }
        /// <summary>
        /// Evaluates a unary expression by performing the corresponding operation on the right operand.
        /// </summary>
        /// <param name="Operator">The unary operator.</param>
        /// <param name="right">The right operand.</param>
        /// <returns>The result of the unary operation.</returns>
        public object EvaluateUnary(Token Operator, object right)
        {
            switch (Operator.Type)
            {
                case TokenType.NOT:
                    CheckBoolean(Operator, right);
                    return !(bool)right;
                case TokenType.SUBSTRACTION:
                    CheckNumber(Operator, right);
                    return -(double)right;
                default:
                    return null;
            }
        }
        /// <summary>
        /// Evaluates a constant expression by retrieving its value from the current scope.
        /// </summary>
        /// <param name="name">The name of the constant.</param>
        /// <returns>The value of the constant.</returns>
        public object EvaluateConstant(string name)
        {
            return Scope.GetValue(name);
            //return CurrentScope().ContainsKey(name)? CurrentScope()[name] : throw new Error(ErrorType.COMPILING, $"Value of {name} wasn't declared.");
        }
        /// <summary>
        /// Evaluates a let-in expression by creating a new scope, declaring the variables and evaluating the body expression.
        /// </summary>
        /// <param name="letIn">The let-in expression to evaluate.</param>
        /// <returns>The result of the body expression.</returns>
        public object EvaluateLetIn(LetExpression letIn)
        {
            //PushScope();
            Scope.EnterScope();
            foreach (Expression instruction in letIn.Instructions)
            {
                Evaluate(instruction);
            }
            object result = Evaluate(letIn.Body);
            //PopScope();
            Scope.ExitScope();
            return result;
        }
        /// <summary>
        /// Evaluates an if-else statement by evaluating the condition and either the then branch or the else branch based on the result.
        /// </summary>
        /// <param name="ifElse">The if-else statement to be evaluated.</param>
        /// <returns>The evaluated value of the executed branch.</returns>
        public object EvaluateIfElse(Conditional ifElse)
        {
            object condition = Evaluate(ifElse.Condition);
            if (!IsBoolean(condition))
                throw new Error(ErrorType.COMPILING, "Condition in 'If-Else' expression must be a boolean expression.");
            return (bool)condition ? Evaluate(ifElse.ThenBranch) : Evaluate(ifElse.ElseBranch);
        }
        /// <summary>
        /// Evaluates a function call expression by evaluating the arguments and executing the function.
        /// </summary>
        /// <param name="call">The function call to evaluate.</param>
        /// <returns>The result of the evaluated function.</returns>
        public object EvaluateCall(Call call)
        {
            Calls++;
            // Evaluate the arguments
            List<object> args = new List<object>();
            foreach (Expression arg in call.Arguments)
                args.Add(Evaluate(arg));

            // Check if the call is to a predefined function
            if (StandardLibrary.PredefinedFunctions.ContainsKey(call.Identifier))
                return StandardLibrary.PredefinedFunctions[call.Identifier](args);

            // Check if the function called is declared
            if (!StandardLibrary.DeclaredFunctions.ContainsKey(call.Identifier))
                throw new Error(ErrorType.COMPILING, $"Function '{call.Identifier}' wasn't declared.");

            // Get the function declaration
            Function function = StandardLibrary.DeclaredFunctions[call.Identifier];
            // Check the amount of arguments of the function vs the arguments passed
            if (args.Count != function.Parameters.Count)
                throw new Error(ErrorType.COMPILING, $"Function '{call.Identifier}' receives '{args.Count}' argument(s) instead of the correct amount '{function.Parameters.Count}'");
            //PushScope();
            Scope.EnterScope();
            // Add the evaluated arguments to the scope
            for (int i = 0; i < function.Parameters.Count; i++)
            {
                string parameterName = function.Parameters[i].ID;
                object argumentValue = args[i];
                //CurrentScope()[parameterName] = argumentValue;
                Scope.SetArgument(parameterName, argumentValue);
            }
            // Evaluate the body of the function
            object result = Evaluate(function.Body);
            //PopScope();
            Scope.ExitScope();
            Calls--;
            return result;
        }
        /// <summary>
        /// Evaluates a random declaration by generating a random value of the given type.
        /// </summary>
        private object EvaluateRandomDeclaration(RandomDeclaration randomDeclaration)
        {
            object result = 0;
            if (randomDeclaration.IsSequence)
            {
                switch (randomDeclaration.Type)
                {
                    case GSharpType.POINT:
                        result = StandardLibrary.RandomPointSequence();
                        break;
                    case GSharpType.LINE:
                        result = StandardLibrary.RandomLineSequence();
                        break;
                    case GSharpType.SEGMENT:
                        result = StandardLibrary.RandomSegmentSequence();
                        break;
                    case GSharpType.RAY:
                        result = StandardLibrary.RandomRaySequence();
                        break;
                    case GSharpType.CIRCLE:
                        result = StandardLibrary.RandomCircleSequence();
                        break;
                    case GSharpType.ARC:
                        result = StandardLibrary.RandomArcSequence();
                        break;
                }
            }
            else
            {
                switch (randomDeclaration.Type)
                {
                    case GSharpType.POINT:
                        result = StandardLibrary.RandomPoint();
                        break;
                    case GSharpType.LINE:
                        result = StandardLibrary.RandomLine();
                        break;
                    case GSharpType.SEGMENT:
                        result = StandardLibrary.RandomSegment();
                        break;
                    case GSharpType.RAY:
                        result = StandardLibrary.RandomRay();
                        break;
                    case GSharpType.CIRCLE:
                        result = StandardLibrary.RandomCircle();
                        break;
                    case GSharpType.ARC:
                        result = StandardLibrary.RandomArc();
                        break;
                }
            }
            return result;
        }


        #region Helper Methods

        /// <summary>
        /// Checks if the operand is a boolean value. Throws a semantic error if it is not.
        /// </summary>
        /// <param name="Operator">The operator token.</param>
        /// <param name="right">The operand to check.</param>
        public void CheckBoolean(Token Operator, object right)
        {
            if (IsBoolean(right)) return;
            throw new Error(ErrorType.COMPILING, $"Operand must be Boolean in '{Operator.Lexeme}' operation.");
        }
        /// <summary>
        /// Checks if the operands are boolean values. Throws a semantic error if they are not.
        /// </summary>
        /// <param name="Operator">The operator token.</param>
        /// <param name="left">The left operand to check.</param>
        /// <param name="right">The right operand to check.</param>
        public void CheckBooleans(Token Operator, object left, object right)
        {
            if (IsBoolean(left, right)) return;
            throw new Error(ErrorType.COMPILING, $"Operands must be Boolean in '{Operator.Lexeme}' operation.");
        }
        /// <summary>
        /// Checks if the operand is a number. Throws a semantic error if it is not.
        /// </summary>
        /// <param name="Operator">The operator token.</param>
        /// <param name="right">The operand to check.</param>
        public void CheckNumber(Token Operator, object right)
        {
            if (IsNumber(right)) return;
            throw new Error(ErrorType.COMPILING, $"Operand must be Number in '{Operator.Lexeme}' operation.");
        }
        /// <summary>
        /// Checks if the operands are numbers. Throws a semantic error if they are not.
        /// </summary>
        /// <param name="Operator">The operator token.</param>
        /// <param name="left">The left operand to check.</param>
        /// <param name="right">The right operand to check.</param>
        public void CheckNumbers(Token Operator, object left, object right)
        {
            if (IsNumber(left, right)) return;
            throw new Error(ErrorType.COMPILING, $"Operands must be Numbers in '{Operator.Lexeme}' operation.");
        }
        /// <summary>
        /// Checks if the given operands are number values.
        /// </summary>
        /// <param name="operands">The operands to check.</param>
        /// <returns><c>true</c> if all operands are numbers; otherwise, <c>false</c>.</returns>
        public bool IsNumber(params object[] operands)
        {
            foreach (object operand in operands)
            {
                if (operand is not double)
                    return false;
            }
            return true;
        }
        /// <summary>
        /// Checks if the given operands are boolean values.
        /// </summary>
        /// <param name="operands">The operands to check.</param>
        /// <returns><c>true</c> if all operands are booleans; otherwise, <c>false</c>.</returns>
        public bool IsBoolean(params object[] operands)
        {
            foreach (object operand in operands)
            {
                if (operand is not bool)
                    return false;
            }
            return true;
        }
        /// <summary>
        /// Checks if the left and right operands are equal.
        /// </summary>
        /// <param name="left">The left operand.</param>
        /// <param name="right">The right operand.</param>
        /// <returns><c>true</c> if the operands are equal; otherwise, <c>false</c>.</returns>
        public bool IsEqual(object left, object right)
        {
            if (left == null && right == null)
                return true;
            return left == null? false : left.Equals(right);
        }
        #endregion
    }
}