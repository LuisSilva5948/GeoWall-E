using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection.Emit;
using System.Text;
using System.IO;

namespace GSharpInterpreter
{
    /// <summary>
    /// Represents an evaluator that evaluates the syntax tree generated by the parser and produces the corresponding runtime values.
    /// </summary>
    public class Evaluator
    {
        private Scope Scope;                                // The scope of the evaluator
        private readonly int CallLimit = 500;               // The maximum amount of calls allowed
        private int Calls;                                  // The amount of calls made
        public List<GSharpError> Errors { get; private set; }     // The list of errors encountered during the evaluation

        public Evaluator()
        {
            Errors = new List<GSharpError>();
            Scope = new Scope();
        }
        public void Evaluate(List<Expression> AST)
        {
            // Evaluate the expressions
            foreach (Expression expression in AST)
            {
                try
                {
                    Evaluate(expression);
                }
                catch(GSharpError error)
                {
                    Errors.Add(error);
                }
                catch (Exception e)
                {
                    Errors.Add(new GSharpError(ErrorType.RUNTIME, e.Message));
                }
            }
        }
        /// <summary>
        /// Evaluates the given expression and returns the result.
        /// </summary>
        /// <param name="expression">The expression to evaluate.</param>
        /// <returns>The result of the evaluation.</returns>
        public object Evaluate(Expression expression)
        {
            // Check if the amount of calls exceeds the call limit
            if (Calls > CallLimit)
                throw new GSharpError(ErrorType.RUNTIME, "Stack Overflow.");

            // Evaluate the expression
            switch (expression)
            {
                // Statements
                case MultipleAssignment multipleAssignment:
                    EvaluateMultipleAssignment(multipleAssignment);
                    return "Constants declared succesfully.";
                case PrintStatement print:
                    EvaluatePrint(print);
                    return "Printed";
                case Assignment assign:
                    Scope.SetConstant(assign.ID, Evaluate(assign.Value));
                    return $"Constant '{assign.ID}' was declared succesfully.";
                case Function function:
                    EvaluateFunction(function);
                    return "Function declared";
                case RestoreStatement:
                    Scope.RestoreColor();
                    return "Color restored";
                case ColorStatement color:
                    Scope.SetColor(color.Color);
                    return "Color changed";
                case DrawStatement draw:
                    EvaluateDraw(draw.Expression);
                    return "Figure drawn";
                case ImportStatement import:
                    EvaluateImport(import);
                    return "Imported";

                case LiteralExpression literal:
                    return literal.Value;
                case UnaryExpression unary:
                    return EvaluateUnary(unary.Operator, Evaluate(unary.Right));
                case BinaryExpression binary:
                    return EvaluateBinary(Evaluate(binary.Left), binary.Operator, Evaluate(binary.Right));
                case GroupingExpression grouping:
                    return Evaluate(grouping.Expression);
                case ConstantExpression constant:
                    return Scope.GetValue(constant.ID);
                
                case Conditional ifElse:
                    return EvaluateIfElse(ifElse);
                case LetExpression letIn:
                    return EvaluateLetIn(letIn);
                case Call call:
                    return EvaluateCall(call);
                case RandomDeclaration randomDeclaration:
                    return EvaluateRandomDeclaration(randomDeclaration);
                
                case Sequence sequence:
                    return sequence;
                case GSharpFigure figure:
                    return figure;
                
                case Undefined undefined:
                    return undefined;
                default:
                    throw new GSharpError(ErrorType.RUNTIME, "Invalid expression.");
            }   
        }
        /// <summary>
        /// Imports the given file and evaluates it to add its contents to the current scope.
        /// </summary>
        private void EvaluateImport(ImportStatement import)
        {
            string path = import.Path;
            string extension = Path.GetExtension(path);
            if (extension == ".txt" || extension == ".geo" || extension == ".gs")
            {
                // Check if the file exists
                if (File.Exists(path))
                {
                    // Read the file
                    string code = File.ReadAllText(path);
                    // Parse the file and add its contents to the current scope
                    try
                    {
                        // Lexing: Convert the source code into a sequence of Tokens
                        Lexer lexer = new Lexer(code);
                        List<Token> tokens = lexer.ScanTokens();
                        // Check for errors in the lexer
                        if (lexer.Errors.Count > 0)
                        {
                            foreach (GSharpError error in lexer.Errors)
                                Errors.Add(new GSharpError(ErrorType.COMPILING, $"Error importing file '{path}': {error.Message}"));
                            return;
                        }
                        // Parsing
                        Parser parser = new Parser(tokens);
                        List<Expression> AST = parser.Parse();
                        // Check for errors in the parser
                        if (parser.Errors.Count > 0)
                        {
                            foreach (GSharpError error in parser.Errors)
                                Errors.Add(new GSharpError(ErrorType.COMPILING, $"Error importing file '{path}': {error.Message}"));
                            return;
                        }
                        // Evaluating: Evaluate the expressions in the AST and produce a result
                        Evaluate(AST);
                    }
                    catch (GSharpError error)
                    {
                        throw new GSharpError(ErrorType.COMPILING, $"Error importing file '{path}': {error.Message}");
                    }
                }
                else throw new GSharpError(ErrorType.COMPILING, $"File '{path}' doesn't exist.");
            }
            else throw new GSharpError(ErrorType.COMPILING, $"File '{path}' must be a .txt, .geo or .gs file.");
        }
        private void EvaluatePrint(PrintStatement print)
        {
            object result = Evaluate(print.Expression);
            string label = "";
            if (print.Label != null)
                 label += " " + print.Label;
            Interpreter.UI.Print(result.ToString() + label);
        }
        private void EvaluateDraw(Expression expression)
        {
            void DrawFigure(GSharpFigure figure)
            {
                switch (figure)
                {
                    case Point point:
                        Interpreter.UI.DrawPoint(point, Scope.GetColor());
                        break;
                    case Line line:
                        Interpreter.UI.DrawLine(line, Scope.GetColor());
                        break;
                    case Segment segment:
                        Interpreter.UI.DrawSegment(segment, Scope.GetColor());
                        break;
                    case Ray ray:
                        Interpreter.UI.DrawRay(ray, Scope.GetColor());
                        break;
                    case Circle circle:
                        Interpreter.UI.DrawCircle(circle, Scope.GetColor());
                        break;
                    case Arc arc:
                        Interpreter.UI.DrawArc(arc, Scope.GetColor());
                        break;
                }
            }
            object expressionToDraw = Evaluate(expression);
            if (expressionToDraw is FiniteSequence sequence)
            {
                foreach (GSharpFigure figure in sequence.Elements)
                {
                    DrawFigure(figure);
                }
            }
            else if (expressionToDraw is GSharpFigure figure)
            {
                DrawFigure(figure);
            }
            else
            {
                throw new GSharpError(ErrorType.COMPILING, "Draw expression must be a sequence of figures of the same type or a figure.");
            }
        }

        private void EvaluateFunction(Function function)
        {
            // Check if the parameters are valid
            foreach (ConstantExpression parameter in function.Parameters)
            {
                if (parameter.ID == "_")
                    throw new GSharpError(ErrorType.COMPILING, "Function parameters can't be named '_'.");
                if (Scope.ExistsIdentifier(parameter.ID))
                    throw new GSharpError(ErrorType.COMPILING, $"Another identifier named '{parameter.ID}' already exists and can't be altered.");
            }
            // Reserve the parameters in the scope
            foreach (ConstantExpression parameter in function.Parameters)
            {
                Scope.Reserve(parameter.ID);
            }
            // Add the function to the declared functions
            Scope.AddFunction(function);
        }

        private void EvaluateMultipleAssignment(MultipleAssignment multipleAssignment)
        {
            List<string> variables = multipleAssignment.IDs;
            object sequence = Evaluate(multipleAssignment.Sequence);
            if (sequence is not Sequence)
                throw new GSharpError(ErrorType.COMPILING, "Multiple assignment can only be done to sequences.");
            if (sequence is FiniteSequence finiteSequence)
            {
                // Get the elements of the sequence
                List<Expression> elements = finiteSequence.GetElements();
                // Iterate through the variables except the last one
                for (int i = 0; i < variables.Count - 1; i++)
                {
                    // If there are no more elements, the variable gets an undefined value
                    if (elements.Count == 0)
                        Scope.SetConstant(variables[i], new Undefined());
                    // Otherwise, the variable gets the value of the next element, and the element is removed from the list
                    else
                    {
                        Scope.SetConstant(variables[i], Evaluate(elements[0]));
                        elements.RemoveAt(0);
                    }
                }
                // The last variable gets the rest of the sequence
                Scope.SetConstant(variables[variables.Count - 1], new FiniteSequence(elements));
            }
            else if (sequence is InfiniteSequence infiniteSequence)
            {
                // Get the enumerator of the sequence
                IEnumerator<double> enumerator = infiniteSequence.GetEnumerator();
                // Iterate through the variables except the last one
                for (int i = 0; i < variables.Count - 1; i++)
                {
                    enumerator.MoveNext();
                    Scope.SetConstant(variables[i], enumerator.Current);
                }
                // The last variable gets the rest of the sequence
                Scope.SetConstant(variables[variables.Count - 1], new InfiniteSequence(enumerator.Current));
            }
            else if (sequence is RangeSequence rangeSequence)
            {
                // Get the enumerator of the sequence
                IEnumerator<double> enumerator = rangeSequence.GetEnumerator();
                // Iterate through the variables except the last one
                for (int i = 0; i < variables.Count - 1; i++)
                {
                    // If there are no more elements, the variable gets an undefined value
                    if (rangeSequence.Count == 0)
                        Scope.SetConstant(variables[i], new Undefined());
                    else if (enumerator.MoveNext())
                    Scope.SetConstant(variables[i], enumerator.Current);
                }
                // The last variable gets the rest of the sequence
                Scope.SetConstant(variables[variables.Count - 1], new RangeSequence(enumerator.Current, rangeSequence.End));
            }
        }


        /// <summary>
        /// Evaluates a binary expression by performing the corresponding operation on the left and right operands.
        /// </summary>
        /// <param name="left">The left operand.</param>
        /// <param name="Operator">The binary operator.</param>
        /// <param name="right">The right operand.</param>
        /// <returns>The result of the binary operation.</returns>
        public object EvaluateBinary(object left, Token Operator, object right)
        {
            switch (Operator.Type)
            {
                case TokenType.ADDITION:
                    try
                    {
                        CheckNumbers(Operator, left, right);
                    }
                    catch(GSharpError)
                    {
                        if (left is string || right is string)
                            return left.ToString() + right.ToString();
                        throw new GSharpError(ErrorType.COMPILING, $"Operands must be Numbers or Strings in '{Operator.Lexeme}' operation.");
                    }
                    return (double)left + (double)right;


                case TokenType.SUBSTRACTION:
                    CheckNumbers(Operator, left, right);
                    return (double)left - (double)right;
                case TokenType.MULTIPLICATION:
                    CheckNumbers(Operator, left, right);
                    return (double)left * (double)right;
                case TokenType.DIVISION:
                    CheckNumbers(Operator, left, right);
                    if ((double)right != 0)
                        return (double)left / (double)right;
                    throw new GSharpError(ErrorType.COMPILING, "Division by zero is undefined.");
                case TokenType.MODULO:
                    CheckNumbers(Operator, left, right);
                    return (double)left % (double)right;
                case TokenType.POWER:
                    CheckNumbers(Operator, left, right);
                    return Math.Pow((double)left, (double)right);
                case TokenType.GREATER:
                    CheckNumbers(Operator, left, right);
                    return (double)left > (double)right;
                case TokenType.GREATER_EQUAL:
                    CheckNumbers(Operator, left, right);
                    return (double)left >= (double)right;
                case TokenType.LESS:
                    CheckNumbers(Operator, left, right);
                    return (double)left < (double)right;
                case TokenType.LESS_EQUAL:
                    CheckNumbers(Operator, left, right);
                    return (double)left <= (double)right;

                case TokenType.EQUAL:
                    return IsEqual(left, right);
                case TokenType.NOT_EQUAL:
                    return !IsEqual(left, right);

                case TokenType.AND:
                    CheckBooleans(Operator, left, right);
                    return (bool)left && (bool)right;
                case TokenType.OR:
                    CheckBooleans(Operator, left, right);
                    return (bool)left || (bool)right;

                default:
                    return null;
            }
        }
        /// <summary>
        /// Evaluates a unary expression by performing the corresponding operation on the right operand.
        /// </summary>
        /// <param name="Operator">The unary operator.</param>
        /// <param name="right">The right operand.</param>
        /// <returns>The result of the unary operation.</returns>
        public object EvaluateUnary(Token Operator, object right)
        {
            switch (Operator.Type)
            {
                case TokenType.NOT:
                    CheckBoolean(Operator, right);
                    return !(bool)right;
                case TokenType.SUBSTRACTION:
                    CheckNumber(Operator, right);
                    return -(double)right;
                default:
                    return null;
            }
        }
        /// <summary>
        /// Evaluates a constant expression by retrieving its value from the current scope.
        /// </summary>
        /// <param name="name">The name of the constant.</param>
        /// <returns>The value of the constant.</returns>
        public object EvaluateConstant(string name)
        {
            return Scope.GetValue(name);
            //return CurrentScope().ContainsKey(name)? CurrentScope()[name] : throw new Error(ErrorType.COMPILING, $"Value of {name} wasn't declared.");
        }
        /// <summary>
        /// Evaluates a let-in expression by creating a new scope, declaring the variables and evaluating the body expression.
        /// </summary>
        /// <param name="letIn">The let-in expression to evaluate.</param>
        /// <returns>The result of the body expression.</returns>
        public object EvaluateLetIn(LetExpression letIn)
        {
            //PushScope();
            Scope.EnterScope();
            foreach (Expression instruction in letIn.Instructions)
            {
                Evaluate(instruction);
            }
            object result = Evaluate(letIn.Body);
            //PopScope();
            Scope.ExitScope();
            return result;
        }
        /// <summary>
        /// Evaluates an if-else statement by evaluating the condition and either the then branch or the else branch based on the result.
        /// </summary>
        /// <param name="ifElse">The if-else statement to be evaluated.</param>
        /// <returns>The evaluated value of the executed branch.</returns>
        public object EvaluateIfElse(Conditional ifElse)
        {
            object condition = Evaluate(ifElse.Condition);
            if (!IsBoolean(condition))
                throw new GSharpError(ErrorType.COMPILING, "Condition in 'If-Else' expression must be a boolean expression.");
            return (bool)condition ? Evaluate(ifElse.ThenBranch) : Evaluate(ifElse.ElseBranch);
        }
        /// <summary>
        /// Evaluates a function call expression by evaluating the arguments and executing the function.
        /// </summary>
        /// <param name="call">The function call to evaluate.</param>
        /// <returns>The result of the evaluated function.</returns>
        public object EvaluateCall(Call call)
        {
            Calls++;
            // Evaluate the arguments
            List<object> arguments = new List<object>();
            foreach (Expression arg in call.Arguments)
                arguments.Add(Evaluate(arg));

            // Check if the call is to a predefined function
            if (StandardLibrary.PredefinedFunctions.ContainsKey(call.Identifier))
                return StandardLibrary.PredefinedFunctions[call.Identifier](arguments);

            // Get the function declaration
            Function function = Scope.GetFunction(call.Identifier);
            // Check the amount of arguments of the function vs the arguments passed
            if (arguments.Count != function.Parameters.Count)
                throw new GSharpError(ErrorType.COMPILING, $"Function '{call.Identifier}' receives '{arguments.Count}' argument(s) instead of the correct amount '{function.Parameters.Count}'");
            
            Scope.EnterScope();
            // Add the evaluated arguments to the scope
            for (int i = 0; i < function.Parameters.Count; i++)
            {
                string parameterName = function.Parameters[i].ID;
                object argumentValue = arguments[i];
                Scope.SetArgument(parameterName, argumentValue);
            }
            // Evaluate the body of the function
            object result = Evaluate(function.Body);
            Scope.ExitScope();
            Calls--;
            return result;
        }
        /// <summary>
        /// Evaluates a random declaration by generating a random value of the given type.
        /// </summary>
        private object EvaluateRandomDeclaration(RandomDeclaration randomDeclaration)
        {
            object result = 0;
            if (randomDeclaration.IsSequence)
            {
                switch (randomDeclaration.Type)
                {
                    case GSharpType.POINT:
                        result = StandardLibrary.RandomPointSequence();
                        break;
                    case GSharpType.LINE:
                        result = StandardLibrary.RandomLineSequence();
                        break;
                    case GSharpType.SEGMENT:
                        result = StandardLibrary.RandomSegmentSequence();
                        break;
                    case GSharpType.RAY:
                        result = StandardLibrary.RandomRaySequence();
                        break;
                    case GSharpType.CIRCLE:
                        result = StandardLibrary.RandomCircleSequence();
                        break;
                    case GSharpType.ARC:
                        result = StandardLibrary.RandomArcSequence();
                        break;
                }
            }
            else
            {
                switch (randomDeclaration.Type)
                {
                    case GSharpType.POINT:
                        result = StandardLibrary.RandomPoint();
                        break;
                    case GSharpType.LINE:
                        result = StandardLibrary.RandomLine();
                        break;
                    case GSharpType.SEGMENT:
                        result = StandardLibrary.RandomSegment();
                        break;
                    case GSharpType.RAY:
                        result = StandardLibrary.RandomRay();
                        break;
                    case GSharpType.CIRCLE:
                        result = StandardLibrary.RandomCircle();
                        break;
                    case GSharpType.ARC:
                        result = StandardLibrary.RandomArc();
                        break;
                }
            }
            return result;
        }


        #region Helper Methods

        /// <summary>
        /// Checks if the operand is a boolean value. Throws a semantic error if it is not.
        /// </summary>
        /// <param name="Operator">The operator token.</param>
        /// <param name="right">The operand to check.</param>
        public void CheckBoolean(Token Operator, object right)
        {
            if (IsBoolean(right)) return;
            throw new GSharpError(ErrorType.COMPILING, $"Operand must be Boolean in '{Operator.Lexeme}' operation.");
        }
        /// <summary>
        /// Checks if the operands are boolean values. Throws a semantic error if they are not.
        /// </summary>
        /// <param name="Operator">The operator token.</param>
        /// <param name="left">The left operand to check.</param>
        /// <param name="right">The right operand to check.</param>
        public void CheckBooleans(Token Operator, object left, object right)
        {
            if (IsBoolean(left, right)) return;
            throw new GSharpError(ErrorType.COMPILING, $"Operands must be Boolean in '{Operator.Lexeme}' operation.");
        }
        /// <summary>
        /// Checks if the operand is a number. Throws a semantic error if it is not.
        /// </summary>
        /// <param name="Operator">The operator token.</param>
        /// <param name="right">The operand to check.</param>
        public void CheckNumber(Token Operator, object right)
        {
            if (IsNumber(right)) return;
            throw new GSharpError(ErrorType.COMPILING, $"Operand must be Number in '{Operator.Lexeme}' operation.");
        }
        /// <summary>
        /// Checks if the operands are numbers. Throws a semantic error if they are not.
        /// </summary>
        /// <param name="Operator">The operator token.</param>
        /// <param name="left">The left operand to check.</param>
        /// <param name="right">The right operand to check.</param>
        public void CheckNumbers(Token Operator, object left, object right)
        {
            if (IsNumber(left, right)) return;
            throw new GSharpError(ErrorType.COMPILING, $"Operands must be Numbers in '{Operator.Lexeme}' operation.");
        }
        /// <summary>
        /// Checks if the given operands are number values.
        /// </summary>
        /// <param name="operands">The operands to check.</param>
        /// <returns><c>true</c> if all operands are numbers; otherwise, <c>false</c>.</returns>
        public bool IsNumber(params object[] operands)
        {
            foreach (object operand in operands)
            {
                if (operand is not double)
                    return false;
            }
            return true;
        }
        /// <summary>
        /// Checks if the given operands are boolean values.
        /// </summary>
        /// <param name="operands">The operands to check.</param>
        /// <returns><c>true</c> if all operands are booleans; otherwise, <c>false</c>.</returns>
        public bool IsBoolean(params object[] operands)
        {
            foreach (object operand in operands)
            {
                if (operand is not bool)
                    return false;
            }
            return true;
        }
        /// <summary>
        /// Checks if the left and right operands are equal.
        /// </summary>
        /// <param name="left">The left operand.</param>
        /// <param name="right">The right operand.</param>
        /// <returns><c>true</c> if the operands are equal; otherwise, <c>false</c>.</returns>
        public bool IsEqual(object left, object right)
        {
            if (left == null && right == null)
                return true;
            return left == null? false : left.Equals(right);
        }
        #endregion
    }
}